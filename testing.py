# -*- coding: utf-8 -*-
"""testing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Zvd5oxBAxjUh9o1fTHcaTRMi5ajOQJnV
"""

import os
from numba import jit, cuda
import cv2
import torch
import torch.nn as nn
import torch.nn.functional as F
import numpy as np
from google.colab import drive

class Network(nn.Module):
  def __init__(self):
    super(Network,self).__init__()
    self.conv1 = nn.Conv2d(in_channels=1,out_channels=5,kernel_size=30)
    self.conv2 = nn.Conv2d(in_channels=5,out_channels=10,kernel_size=10)
    self.conv3 = nn.Conv2d(in_channels=10,out_channels=10,kernel_size=5)
    self.fc1 = nn.Linear(in_features=160,out_features=100)
    self.fc2 = nn.Linear(in_features=100,out_features=50)
    self.fc3 = nn.Linear(in_features=50,out_features=20)
    self.fc4 = nn.Linear(in_features=20,out_features=1)

  def forward(self,t1,t2):
    m = nn.Sigmoid()
    t=t1
    m2 = nn.MaxPool2d(kernel_size=2,stride=2)
    t = self.conv1(t)
    t = F.relu(t)
    t = m2(t)
    t = self.conv2(t)
    t = F.relu(t)
    t = m2(t)
    t = self.conv3(t)
    t = F.relu(t)
    t = m2(t)
    t = t.reshape(1,160)
    t = self.fc1(t)
    t =F.relu(t)
    t = self.fc2(t)
    t = F.relu(t)
    t = self.fc3(t)
    t = F.relu(t)
    t = self.fc4(t)
    t =  m(t)
    t2 = self.conv1(t2)
    t2 = F.relu(t2)
    t2 = m2(t2)
    t2 = self.conv2(t2)
    t2 = F.relu(t2)
    t2 = m2(t2)
    t2 = self.conv3(t2)
    t2 = F.relu(t2)
    t2 = m2(t2)
    t2 = t2.reshape(1,160)
    t2 = self.fc1(t2)
    t2 = F.relu(t2)
    t2 = self.fc2(t2)
    t2 = F.relu(t2)
    t2 = self.fc3(t2)
    t2 = F.relu(t2)
    t2 = self.fc4(t2)
    t2 = m(t2)
    return t,t2
  
net = Network()
net.load_state_dict(torch.load('final_model'))
net.double()

def format(path):
  img = cv2.imread(path)
  img = cv2.cvtColor(img,cv2.COLOR_RGB2GRAY)
  face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
  #getting coordinates of faces
  rects = np.array(face_cascade.detectMultiScale(img,1.2,10))
  #if number of faces in the image is 1,then only the face is selected.
  img2=[[-1]]
  if rects.shape[0]==1:
    (x,y,w,h) = rects[0]
    img = img[y:y+h,x:x+w]
    img = cv2.resize(img,(100,100))
    img = np.array(img,dtype=np.float64)
    img2 =img
  return img2

print('enter the path for the image 1')
path1=input()
print('enter the path for the image 2')
path2=input()
img1=torch.tensor(format(path1),dtype=torch.double).reshape(1,1,100,100)
img2=torch.tensor(format(path2),dtype=torch.double).reshape(1,1,100,100)
out1,out2=net(img1/255,img2/255)
out1=out1[0][0]
out2=out2[0][0]
confidence=min(out1,out2)/max(out1,out2)*100
print('confidence:',confidence.item(),'%')
if confidence > 90:
  print('pictures are matching')
else:
  print('pictures are not matching')

